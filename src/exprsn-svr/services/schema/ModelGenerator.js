/**
 * ═══════════════════════════════════════════════════════════
 * Model Generator Service
 * Generates Sequelize model files from schema definitions
 * ═══════════════════════════════════════════════════════════
 */

const fs = require('fs').promises;
const path = require('path');

class ModelGenerator {
  /**
   * Generate Sequelize model from table definition
   */
  static generateModel(table, schema, options = {}) {
    const { includeAssociations = true } = options;
    const className = this.toPascalCase(table.name);
    const columns = table.columns || [];

    let modelContent = this.generateHeader(table, className);
    modelContent += this.generateClass(table, className, columns);
    modelContent += this.generateInitMethod(table, className, columns);

    if (includeAssociations) {
      modelContent += this.generateAssociateMethod(table, schema);
    }

    modelContent += this.generateInstanceMethods(table, columns);
    modelContent += this.generateClassMethods(table);
    modelContent += this.generateExport(className);

    return {
      fileName: `${className}.js`,
      content: modelContent,
      className
    };
  }

  /**
   * Generate file header
   */
  static generateHeader(table, className) {
    return `/**
 * ═══════════════════════════════════════════════════════════
 * ${className} Model
 * ${table.description || table.displayName}
 * Generated by Exprsn Schema Designer
 * ═══════════════════════════════════════════════════════════
 */

const { Model, DataTypes } = require('sequelize');

`;
  }

  /**
   * Generate class definition
   */
  static generateClass(table, className, columns) {
    return `class ${className} extends Model {\n`;
  }

  /**
   * Generate init method
   */
  static generateInitMethod(table, className, columns) {
    let code = `  static init(sequelize) {\n`;
    code += `    return super.init({\n`;

    // Add columns
    columns.forEach((col, index) => {
      code += `      ${col.name}: {\n`;
      code += `        type: DataTypes.${this.mapDataType(col.dataType, col)},\n`;

      if (col.isPrimaryKey) {
        code += `        primaryKey: true,\n`;
      }

      if (col.dataType === 'UUID' && col.isPrimaryKey) {
        code += `        defaultValue: DataTypes.UUIDV4,\n`;
      }

      if (!col.isNullable) {
        code += `        allowNull: false,\n`;
      }

      if (col.isUnique) {
        code += `        unique: true,\n`;
      }

      if (col.isAutoIncrement) {
        code += `        autoIncrement: true,\n`;
      }

      if (col.defaultValue) {
        code += `        defaultValue: ${this.formatDefaultValue(col.defaultValue, col.dataType)},\n`;
      }

      if (col.description) {
        code += `        comment: '${col.description.replace(/'/g, "\\'")}',\n`;
      }

      // Field name mapping for snake_case
      if (col.name.includes('_')) {
        const camelCase = this.toCamelCase(col.name);
        if (camelCase !== col.name) {
          code += `        field: '${col.name}',\n`;
        }
      }

      // Validation
      if (col.metadata && col.metadata.validation) {
        code += `        validate: ${JSON.stringify(col.metadata.validation, null, 10)},\n`;
      }

      code = code.replace(/,\n$/, '\n');
      code += `      }${index < columns.length - 1 ? ',' : ''}\n`;
    });

    code += `    }, {\n`;
    code += `      sequelize,\n`;
    code += `      modelName: '${className}',\n`;
    code += `      tableName: '${table.name}',\n`;

    if (table.isSoftDelete) {
      code += `      paranoid: true,\n`;
    }

    code += `      underscored: true,\n`;
    code += `      timestamps: ${table.isAudited ? 'true' : 'false'}\n`;
    code += `    });\n`;
    code += `  }\n\n`;

    return code;
  }

  /**
   * Generate associate method
   */
  static generateAssociateMethod(table, schema) {
    const relationships = schema.relationships?.filter(r =>
      r.sourceTableId === table.id || r.targetTableId === table.id
    ) || [];

    if (relationships.length === 0) {
      return '';
    }

    let code = `  static associate(models) {\n`;

    relationships.forEach(rel => {
      const isSource = rel.sourceTableId === table.id;
      const targetTable = schema.tables?.find(t =>
        t.id === (isSource ? rel.targetTableId : rel.sourceTableId)
      );

      if (!targetTable) return;

      const targetClassName = this.toPascalCase(targetTable.name);
      const sourceColumn = table.columns?.find(c => c.id === rel.sourceColumnId);

      if (rel.relationshipType === 'one_to_many' && isSource) {
        code += `    this.hasMany(models.${targetClassName}, {\n`;
        code += `      foreignKey: '${sourceColumn?.name || 'id'}',\n`;
        code += `      as: '${this.pluralize(this.toCamelCase(targetTable.name))}'\n`;
        code += `    });\n`;
      } else if (rel.relationshipType === 'many_to_one' && !isSource) {
        code += `    this.belongsTo(models.${targetClassName}, {\n`;
        code += `      foreignKey: '${sourceColumn?.name || 'id'}',\n`;
        code += `      as: '${this.toCamelCase(targetTable.name)}'\n`;
        code += `    });\n`;
      } else if (rel.relationshipType === 'one_to_one' && isSource) {
        code += `    this.hasOne(models.${targetClassName}, {\n`;
        code += `      foreignKey: '${sourceColumn?.name || 'id'}',\n`;
        code += `      as: '${this.toCamelCase(targetTable.name)}'\n`;
        code += `    });\n`;
      } else if (rel.relationshipType === 'many_to_many') {
        const junctionTable = schema.tables?.find(t => t.id === rel.junctionTableId);
        if (junctionTable) {
          code += `    this.belongsToMany(models.${targetClassName}, {\n`;
          code += `      through: '${junctionTable.name}',\n`;
          code += `      as: '${this.pluralize(this.toCamelCase(targetTable.name))}'\n`;
          code += `    });\n`;
        }
      }
    });

    code += `  }\n\n`;
    return code;
  }

  /**
   * Generate instance methods
   */
  static generateInstanceMethods(table, columns) {
    let code = '';

    // Generate toJSON override if needed
    const sensitiveFields = columns.filter(c =>
      c.metadata?.sensitive || c.name.includes('password') || c.name.includes('secret')
    );

    if (sensitiveFields.length > 0) {
      code += `  toJSON() {\n`;
      code += `    const values = { ...this.get() };\n`;
      sensitiveFields.forEach(field => {
        code += `    delete values.${field.name};\n`;
      });
      code += `    return values;\n`;
      code += `  }\n\n`;
    }

    return code;
  }

  /**
   * Generate class methods
   */
  static generateClassMethods(table) {
    let code = '';

    // Generate findActive if soft deletes enabled
    if (table.isSoftDelete) {
      code += `  static async findActive(options = {}) {\n`;
      code += `    return this.findAll({\n`;
      code += `      ...options,\n`;
      code += `      where: {\n`;
      code += `        ...options.where,\n`;
      code += `        deletedAt: null\n`;
      code += `      }\n`;
      code += `    });\n`;
      code += `  }\n\n`;
    }

    return code;
  }

  /**
   * Generate export
   */
  static generateExport(className) {
    return `}\n\nmodule.exports = ${className};\n`;
  }

  /**
   * Map data type to Sequelize DataTypes
   */
  static mapDataType(dataType, column) {
    const typeMap = {
      'UUID': 'UUID',
      'VARCHAR': column.length ? `STRING(${column.length})` : 'STRING',
      'TEXT': 'TEXT',
      'INTEGER': 'INTEGER',
      'BIGINT': 'BIGINT',
      'DECIMAL': column.precision && column.scale
        ? `DECIMAL(${column.precision}, ${column.scale})`
        : 'DECIMAL',
      'FLOAT': 'FLOAT',
      'DOUBLE': 'DOUBLE',
      'BOOLEAN': 'BOOLEAN',
      'DATE': 'DATEONLY',
      'TIMESTAMP': 'DATE',
      'TIMESTAMPTZ': 'DATE',
      'JSONB': 'JSONB',
      'JSON': 'JSON',
      'ARRAY': 'ARRAY(DataTypes.STRING)',
      'ENUM': 'ENUM',
      'GEOMETRY': 'GEOMETRY',
      'GEOGRAPHY': 'GEOGRAPHY'
    };

    return typeMap[dataType.toUpperCase()] || 'STRING';
  }

  /**
   * Format default value
   */
  static formatDefaultValue(value, dataType) {
    if (value === 'NOW()' || value === 'CURRENT_TIMESTAMP') {
      return 'DataTypes.NOW';
    }

    if (value === 'UUID()' || value === 'gen_random_uuid()') {
      return 'DataTypes.UUIDV4';
    }

    if (dataType === 'BOOLEAN') {
      return value === 'true' || value === '1' ? 'true' : 'false';
    }

    if (dataType === 'INTEGER' || dataType === 'BIGINT' || dataType === 'DECIMAL') {
      return value;
    }

    if (dataType === 'JSONB' || dataType === 'JSON') {
      return `'${value}'`;
    }

    return `'${value}'`;
  }

  /**
   * Convert to PascalCase
   */
  static toPascalCase(str) {
    return str.split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }

  /**
   * Convert to camelCase
   */
  static toCamelCase(str) {
    const pascal = this.toPascalCase(str);
    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
  }

  /**
   * Simple pluralize
   */
  static pluralize(str) {
    if (str.endsWith('y')) {
      return str.slice(0, -1) + 'ies';
    }
    if (str.endsWith('s')) {
      return str;
    }
    return str + 's';
  }

  /**
   * Generate all models for a schema
   */
  static async generateAllModels(schema, options = {}) {
    const models = [];

    for (const table of schema.tables || []) {
      const model = this.generateModel(table, schema, options);
      models.push(model);
    }

    // Generate index.js
    const indexContent = this.generateModelsIndex(models, schema);
    models.push({
      fileName: 'index.js',
      content: indexContent,
      className: 'index'
    });

    return models;
  }

  /**
   * Generate models/index.js
   */
  static generateModelsIndex(models, schema) {
    let code = `/**
 * Models Index
 * Auto-generated by Exprsn Schema Designer
 */

const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');

const sequelize = new Sequelize(
  process.env.DB_NAME || '${schema.databaseName || 'database'}',
  process.env.DB_USER || 'postgres',
  process.env.DB_PASSWORD || '',
  {
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || 5432,
    dialect: 'postgres',
    logging: process.env.NODE_ENV === 'development' ? console.log : false,
    pool: {
      max: 10,
      min: 2,
      acquire: 30000,
      idle: 10000
    }
  }
);

const db = {};

// Import models
`;

    models.filter(m => m.className !== 'index').forEach(model => {
      code += `db.${model.className} = require('./${model.className}');\n`;
    });

    code += `\n// Initialize models\n`;
    models.filter(m => m.className !== 'index').forEach(model => {
      code += `db.${model.className}.init(sequelize);\n`;
    });

    code += `\n// Setup associations\n`;
    models.filter(m => m.className !== 'index').forEach(model => {
      code += `if (db.${model.className}.associate) {\n`;
      code += `  db.${model.className}.associate(db);\n`;
      code += `}\n`;
    });

    code += `\ndb.sequelize = sequelize;\ndb.Sequelize = Sequelize;\n\nmodule.exports = db;\n`;

    return code;
  }

  /**
   * Save model file to disk
   */
  static async saveModelFile(model, modelsDir) {
    const filePath = path.join(modelsDir, model.fileName);
    await fs.mkdir(modelsDir, { recursive: true });
    await fs.writeFile(filePath, model.content, 'utf8');
    return filePath;
  }
}

module.exports = ModelGenerator;
